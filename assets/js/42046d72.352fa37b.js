"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[636],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,f=c["".concat(s,".").concat(m)]||c[m]||u[m]||o;return n?a.createElement(f,l(l({ref:t},d),{},{components:n})):a.createElement(f,l({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=c;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9303:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={title:"Lambda layers",date:"2022-10-05 06:00:00 +0000",displayed_sidebar:"aws"},l=void 0,i={unversionedId:"aws-sam/lambda-layers",id:"aws-sam/lambda-layers",title:"Lambda layers",description:"If you are using ZIP as a packaging system with your lambdas, you can use layers to share code & dependencies across teams in your organization. This tutorial will show how lambda handles layers in the node js environment and how we can create a layer with AWS SAM.",source:"@site/docs/aws-sam/04-lambda-layers.md",sourceDirName:"aws-sam",slug:"/aws-sam/lambda-layers",permalink:"/tutorials/aws-sam/lambda-layers",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Lambda layers",date:"2022-10-05 06:00:00 +0000",displayed_sidebar:"aws"},sidebar:"aws",previous:{title:"Delete",permalink:"/tutorials/aws-sam/todo-app/delete-todo"}},s={},p=[{value:"Intro",id:"intro",level:2},{value:"Add layers",id:"add-layers",level:2},{value:"tsconfig.json",id:"tsconfigjson",level:3},{value:"webpack.config.js",id:"webpackconfigjs",level:3},{value:"template.yaml",id:"templateyaml",level:3}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"If you are using ",(0,r.kt)("strong",{parentName:"p"},"ZIP")," as a packaging system with your lambdas, you can use layers to share code & dependencies across teams in your organization. This tutorial will show how lambda handles layers in the node js environment and how we can create a layer with AWS SAM."),(0,r.kt)("h2",{id:"intro"},"Intro"),(0,r.kt)("p",null,"In our code, if we are importing a function such as"),(0,r.kt)("blockquote",null,(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { fun } from 'fun-lib';\n"))),(0,r.kt)("p",null,"then the node will try to resolve this dependency from the local ",(0,r.kt)("inlineCode",{parentName:"p"},"node_modules")," folder OR from the path specified by the ",(0,r.kt)("inlineCode",{parentName:"p"},"NODE_PATH")," env variable OR from ",(0,r.kt)("inlineCode",{parentName:"p"},"/opt/nodejs/node_modules"),". If our ",(0,r.kt)("inlineCode",{parentName:"p"},"fun-lib")," is stored inside ",(0,r.kt)("inlineCode",{parentName:"p"},"nodejs/node_modules/fun-lib"),", then our code will work without any import problems."),(0,r.kt)("p",null,"When lambda prepares the execution environment for our function, it extracts the content of our layer's zip file into the ",(0,r.kt)("inlineCode",{parentName:"p"},"/opt")," directory. If we keep the path for our dependencies as ",(0,r.kt)("inlineCode",{parentName:"p"},"nodejs/node_modules/dependency-pkg"),", then we can import these dependencies in our code without specifying the path."),(0,r.kt)("p",null,"Let's continue with our ",(0,r.kt)("strong",{parentName:"p"},"todo")," app to see how we can create and upload lambda layers from our local system. Download ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/VinitTomar/todo-aws-sam/tree/impr"},"this")," code to begin with our tutorial."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"add-layers"},"Add layers"),(0,r.kt)("p",null,"When you look at the code, you will find a folder ",(0,r.kt)("strong",{parentName:"p"},"util")," with two files ",(0,r.kt)("inlineCode",{parentName:"p"},"helper.ts")," & ",(0,r.kt)("inlineCode",{parentName:"p"},"todo-put.ts"),". For these two files, we are going to create two layers ",(0,r.kt)("inlineCode",{parentName:"p"},"LayerHelper")," & ",(0,r.kt)("inlineCode",{parentName:"p"},"LayerTodoPut")," respectively."),(0,r.kt)("p",null,"Open file ",(0,r.kt)("inlineCode",{parentName:"p"},"todo-create.ts")," and observe how we have imported functions from files inside the ",(0,r.kt)("strong",{parentName:"p"},"util")," folder."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { putTodo } from "./util/todo-put";\nimport { lambdaWrapper, jsonResponse } from "./util/helper";\n')),(0,r.kt)("p",null,"If we want these imports to be included from our lambda layers, then we need to adjust these imports as below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { putTodo } from "@util/todo-put";\nimport { lambdaWrapper, jsonResponse } from "@util/helper";\n')),(0,r.kt)("h3",{id:"tsconfigjson"},"tsconfig.json"),(0,r.kt)("p",null,"We also need to tell ",(0,r.kt)("strong",{parentName:"p"},"tsc compiler")," where it can locate files for scope ",(0,r.kt)("inlineCode",{parentName:"p"},"@util"),", hence update the ",(0,r.kt)("inlineCode",{parentName:"p"},"tsconfig")," with the below code."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:'showLineNumbers title="tsconfig.json"',showLineNumbers:!0,title:'"tsconfig.json"'},'{\n  "compilerOptions": {\n    "baseUrl": "./src",\n    "target": "es2020",\n    "strict": true,\n    "preserveConstEnums": true,\n    "sourceMap": false,\n    "module": "es2015",\n    "moduleResolution": "node",\n    "esModuleInterop": true,\n    "skipLibCheck": true,\n    "forceConsistentCasingInFileNames": true,\n    "paths": {\n      "@util/*": [\n        "./util/*"\n      ]\n    }\n  },\n  "exclude": [\n    "node_modules",\n    "**/*.test.ts"\n  ]\n}\n')),(0,r.kt)("p",null,"At ",(0,r.kt)("strong",{parentName:"p"},"line 3")," we have added ",(0,r.kt)("inlineCode",{parentName:"p"},"baseUrl")," which points to the ",(0,r.kt)("inlineCode",{parentName:"p"},"./src")," folder and at ",(0,r.kt)("strong",{parentName:"p"},"line 13")," we have configured ",(0,r.kt)("strong",{parentName:"p"},"paths")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"@util/*")," which points to the ",(0,r.kt)("inlineCode",{parentName:"p"},"./util/*")," folder."),(0,r.kt)("h3",{id:"webpackconfigjs"},"webpack.config.js"),(0,r.kt)("p",null,"We are using webpack for bundling our application. We need to update the ",(0,r.kt)("inlineCode",{parentName:"p"},"webpack.config.js")," file so that ",(0,r.kt)("strong",{parentName:"p"},"webpack")," can generate js files as required by lambda layers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'showLineNumbers title="webpack.config.js"',showLineNumbers:!0,title:'"webpack.config.js"'},"const path = require('path');\nconst fs = require('fs');\nconst TsconfigPathsPlugin = require('tsconfig-paths-webpack-plugin');\n\nconst entry = fs.readdirSync('./src/')\n  .filter(file => (file.endsWith('.ts')\n    && !file.endsWith('.d.ts')\n    && !file.includes('util'))\n  )\n  .reduce((result, curr) => {\n    const name = curr.replace('.ts', '');\n    result[name] = './src/' + curr;\n    return result;\n  }, {});\n\nconst layerEntry = fs.readdirSync('./src/util/')\n  .reduce((result, curr) => {\n    const name = curr.replace('.ts', '');\n    const dirName = `layer_${name}/nodejs/node_modules/@util/${name}`;\n    result[dirName] = `./src/util/${curr}`;\n    return result;\n  }, {});\n\nconst layerExternals = fs.readdirSync('./src/util')\n  .reduce((result, curr) => {\n    const name = curr.replace('.ts', '');\n    result[`@util/${name}`] = true;\n    return result;\n  }, {});\n\nmodule.exports = {\n  mode: 'production',\n  entry: { ...entry, ...layerEntry },\n  target: 'node',\n  externals: {\n    'aws-sdk/clients/dynamodb': true,\n    ...layerExternals\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: 'ts-loader',\n        exclude: /node_modules/,\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.js'],\n    plugins: [\n      new TsconfigPathsPlugin({\n        configFile: \"./tsconfig.json\"\n      }),\n    ],\n  },\n  output: {\n    filename: '[name]/index.js',\n    path: path.resolve(__dirname, 'dist'),\n    libraryTarget: 'commonjs2',\n    clean: true\n  },\n};\n")),(0,r.kt)("p",null,"To make webpack aware of paths in ",(0,r.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," file we need to use plugin ",(0,r.kt)("strong",{parentName:"p"},"TsconfigPathsPlugin"),". Install this plugin as a dev dependency inside our project. This plugin will create aliases for webpack according to the paths in the ts config file. Therefore we do not need to maintain the same configurations at two places. We have added a new instance of ",(0,r.kt)("strong",{parentName:"p"},"TsconfigPathsPlugin")," plugin at ",(0,r.kt)("strong",{parentName:"p"},"line 51")," & imported it at ",(0,r.kt)("strong",{parentName:"p"},"line 3"),"."),(0,r.kt)("p",null,"From lines ",(0,r.kt)("strong",{parentName:"p"},"16 to 22"),", we have initialized ",(0,r.kt)("inlineCode",{parentName:"p"},"layerEntry")," which has the configuration for entries of our source code. Keys in this configuration will help in generating ",(0,r.kt)("strong",{parentName:"p"},"js files")," for our layers inside the ",(0,r.kt)("strong",{parentName:"p"},"dist"),' folder. We will have folders named "',(0,r.kt)("inlineCode",{parentName:"p"},"layer_file-name"),'" where ',(0,r.kt)("inlineCode",{parentName:"p"},"file-name")," is the name of a file inside the ",(0,r.kt)("strong",{parentName:"p"},"util")," folder. Now you can figure out from ",(0,r.kt)("strong",{parentName:"p"},"keys")," what path will be generated for our ",(0,r.kt)("strong",{parentName:"p"},"js")," required by lambda layers."),(0,r.kt)("p",null,"We also need to make ",(0,r.kt)("strong",{parentName:"p"},"util")," imports as ",(0,r.kt)("strong",{parentName:"p"},"external dependencies")," so that webpack does not bundle these with lambda handler code. Code from ",(0,r.kt)("strong",{parentName:"p"},"lines 24 to 29")," is generating configuration for making ",(0,r.kt)("strong",{parentName:"p"},"util")," imports as external dependencies."),(0,r.kt)("p",null,"Add ",(0,r.kt)("inlineCode",{parentName:"p"},"layerEntry")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"entry")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"layerExternals")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"externals")," of webpack config."),(0,r.kt)("p",null,"Now run ",(0,r.kt)("inlineCode",{parentName:"p"},"yarn build")," to generate code for our layers. Open ",(0,r.kt)("strong",{parentName:"p"},"dist")," folder and you will see ",(0,r.kt)("strong",{parentName:"p"},"layer_helper")," & ",(0,r.kt)("strong",{parentName:"p"},"layer_todo-put")," folder inside it. These two folders contain code for our ",(0,r.kt)("strong",{parentName:"p"},"LayerHelper")," and ",(0,r.kt)("strong",{parentName:"p"},"LayerTodoPut")," layers."),(0,r.kt)("h3",{id:"templateyaml"},"template.yaml"),(0,r.kt)("p",null,"Add two ",(0,r.kt)("strong",{parentName:"p"},"resources")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"AWS::Serverless::LayerVersion")," to our ",(0,r.kt)("inlineCode",{parentName:"p"},"template.yaml")," file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"showLineNumbers",showLineNumbers:!0},'LayerHelper:\n    Type: AWS::Serverless::LayerVersion\n    Properties:\n      LayerName: LayerHelper\n      Description: Helper layer for todo lambdas.\n      ContentUri: "dist/layer_helper/"\n      CompatibleRuntimes:\n        - nodejs16.x\n\nLayerTodoPut:\n  Type: AWS::Serverless::LayerVersion\n  Properties:\n    LayerName: LayerTodoPut\n    Description: TodoPut layer for create & update todo lambdas.\n    ContentUri: "dist/layer_todo-put/"\n    CompatibleRuntimes:\n      - nodejs16.x\n')),(0,r.kt)("p",null,"If you run ",(0,r.kt)("inlineCode",{parentName:"p"},"yarn deploy")," this will create two lambda layers as per the ",(0,r.kt)("strong",{parentName:"p"},"template.yaml")," configuration. You can verify the same by navigation to the lambda layers page in your AWS console account."),(0,r.kt)("p",null,"Now lets add these layers to our lambda ",(0,r.kt)("strong",{parentName:"p"},"CreateTodoFunction")," function. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"showLineNumbers",showLineNumbers:!0},"CreateTodoFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: dist/todo-create\n      Handler: index.createTodoHandler\n      Layers:\n        - !Ref LayerHelper\n        - !Ref LayerTodoPut\n      Policies:\n        - DynamoDBCrudPolicy:\n            TableName: !Ref TodoTable\n      Environment:\n        Variables:\n          TODO_TABLE: !Ref TodoTable\n      Events:\n        CreateTodo:\n          Type: Api\n          Properties:\n            Path: /todos\n            Method: POST\n")),(0,r.kt)("p",null,"On ",(0,r.kt)("strong",{parentName:"p"},"lines 7 & 8")," we have added our layers. These will be available for our function at the execution time."),(0,r.kt)("p",null,"If you look in the file ",(0,r.kt)("inlineCode",{parentName:"p"},"src/todo-by-id.ts"),", we are only importing functions from the ",(0,r.kt)("strong",{parentName:"p"},"helper")," file. Therefore for our function ",(0,r.kt)("strong",{parentName:"p"},"GetTodosFunction")," we only need to add ",(0,r.kt)("strong",{parentName:"p"},"LayerHelper")," layer. Now update the import for all the todo files & add the required layers to all lambda functions in ",(0,r.kt)("inlineCode",{parentName:"p"},"template.yaml")," file."),(0,r.kt)("p",null,"Now you can deploy your code and check if it is working as expected."),(0,r.kt)("admonition",{title:"Check list",type:"caution"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"For a single lambda function, we can only add up to 5 lambda layers."),(0,r.kt)("li",{parentName:"ul"},"Total size of a lambda function should not exceed more than 250 MB including the size of all layers combined."),(0,r.kt)("li",{parentName:"ul"},"If you want to use lambda layers to overcome the 250 MB size restriction, you are looking at the wrong place. You need to use container images that support up to 10GB of size."))))}u.isMDXComponent=!0}}]);